NoKey: Ничего не происходит, на следующем такте сохраняется флаг NoKey. Если приходят входные данные ставится флаг Total_RST.
KeyOK: Ключ получен, ничего не происходит, на следующем такте устанавливается флаг Init.
Init: Флаг держится 1522 такта, в которые происходит начальная инициализация регистров ключевого потока. После устанавливается флаг Wait_Data.
Wait_Data: Идет ожидание входных данных, если они приходят, устанавливается флаг Moving_Secret, иначе флаг сохраняется.
Moving_Secret:С приходом новых бит данных, происходит их шифрование. Как происходит остановка? 256 байт? Предположим, что так. После устанавливается флаг Secret_Ready.
Secret_Ready: Данные готовы к отправке. Если приходят данные, они теряются, флаг сохраняется. Если состояние буфера становится "пуст", устанавливается флаг Wait_Data.
Error: Устанавливается, когда количество зашифрованных данных превысит 2^64. Если приходят данные, устанавливается флаг Total_RST.
Total_RST: Происходит полное обнуление регистров ключевого потока и вспомогательных переменных. Блок шифрования полностью переходит в начальное состояние.

//Это ни разу не рабочий код. Нужны флаги.
/*always_ff@(posedge clk, negedge rst)
	if (!rst)
		stream<=0;
	else if (count<=11'b10010000000)
	begin
		t_1<=reg_str_1[65]^reg_str_1[92];
		t_2<=reg_str_2[68]^reg_str_2[83];
		t_3<=reg_str_3[65]^reg_str_3[110];
		
		z<=t_1^t_2^t_3;
		
		t_1<=t_1^reg_str_1[90]&reg_str_1[91]^reg_str_2[78];
		t_2<=t_2^reg_str_2[81]&reg_str_2[82]^reg_str_3[86];
		t_3<=t_3^reg_str_3[108]&reg_str_3[109]^reg_str_1[68];
		
		reg_str_1<=reg_str_1<<1;
		reg_str_1[0]<=t_3;
		reg_str_2<=reg_str_2<<1;
		reg_str_2[0]<=t_1;
		reg_str_3<=reg_str_3<<1;
		reg_str_3[0]<=t_2;
	end*/